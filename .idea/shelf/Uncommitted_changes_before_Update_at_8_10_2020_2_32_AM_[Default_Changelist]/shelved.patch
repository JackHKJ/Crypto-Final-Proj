Index: ECCryp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import collections\r\nimport random\r\nimport binascii\r\n\r\n#code curve is based on Standards for Efficient Cryptography Group\r\n\r\nEllipticCurve = collections.namedtuple('EllipticCurve', 'name p a b g n h')\r\n\r\ncurve = EllipticCurve(\r\n    'secp256k1',\r\n    # Field characteristic.\r\n    p=0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f,\r\n    # Curve coefficients.\r\n    a=0,\r\n    b=7,\r\n    # Base point.\r\n    g=(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,\r\n       0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8),\r\n    # Subgroup order.\r\n    n=0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141,\r\n    # Subgroup cofactor.\r\n    h=1,\r\n)\r\n\r\n\r\ndef stohx(a):\r\n    return \"\".join(\"{:02x}\".format(ord(c)) for c in a)\r\n\r\n\r\ndef hxtos(a):\r\n    return bytearray.fromhex(a).decode()\r\n\r\n\r\ndef hxtoi(a):\r\n    return int(a,16)\r\n\r\n\r\ndef itohx(a):\r\n    return hex(a)[2:]\r\n\r\n\r\n# Modular arithmetic ##########################################################\r\n# credit https://github.com/andreacorbellini/ecc/blob/master/scripts/ecdhe.py\r\ndef inverse_mod(k, p):\r\n    if k == 0:\r\n        raise ZeroDivisionError('division by zero')\r\n\r\n    if k < 0:\r\n        # k ** -1 = p - (-k) ** -1  (mod p)\r\n        return p - inverse_mod(-k, p)\r\n\r\n    # Extended Euclidean algorithm.\r\n    s, old_s = 0, 1\r\n    t, old_t = 1, 0\r\n    r, old_r = p, k\r\n\r\n    while r != 0:\r\n        quotient = old_r // r\r\n        old_r, r = r, old_r - quotient * r\r\n        old_s, s = s, old_s - quotient * s\r\n        old_t, t = t, old_t - quotient * t\r\n    gcd, x, y = old_r, old_s, old_t\r\n    assert gcd == 1\r\n    assert (k * x) % p == 1\r\n    return x % p\r\n\r\n\r\n# Used to calculate Nb or Na times the point\r\ndef is_on_curve(point):\r\n    if point is None:\r\n        return True\r\n    x, y = point\r\n    return (y * y - x * x * x - curve.a * x - curve.b) % curve.p == 0\r\n\r\n\r\ndef point_neg(point):\r\n    assert is_on_curve(point)\r\n    if point is None:\r\n        # -0 = 0\r\n        return None\r\n\r\n    x, y = point\r\n    result = (x, -y % curve.p)\r\n\r\n    assert is_on_curve(result)\r\n\r\n    return result\r\n\r\n\r\n# credit https://github.com/andreacorbellini/ecc/blob/master/scripts/ecdhe.py\r\ndef point_add(point1, point2):\r\n    \"\"\"Returns the result of point1 + point2 according to the group law.\"\"\"\r\n    assert is_on_curve(point1)\r\n    assert is_on_curve(point2)\r\n\r\n    if point1 is None:\r\n        # 0 + point2 = point2\r\n        return point2\r\n    if point2 is None:\r\n        # point1 + 0 = point1\r\n        return point1\r\n\r\n    x1, y1 = point1\r\n    x2, y2 = point2\r\n\r\n    if x1 == x2 and y1 != y2:\r\n        # point1 + (-point1) = 0\r\n        return None\r\n\r\n    if x1 == x2:\r\n        # This is the case point1 == point2.\r\n        m = (3 * x1 * x1 + curve.a) * inverse_mod(2 * y1, curve.p)\r\n    else:\r\n        # This is the case point1 != point2.\r\n        m = (y1 - y2) * inverse_mod(x1 - x2, curve.p)\r\n\r\n    x3 = m * m - x1 - x2\r\n    y3 = y1 + m * (x3 - x1)\r\n    result = (x3 % curve.p,\r\n              -y3 % curve.p)\r\n\r\n    assert is_on_curve(result)\r\n\r\n    return result\r\n\r\n\r\n# credit https://github.com/andreacorbellini/ecc/blob/master/scripts/ecdhe.py\r\ndef scalar_mult(k, point):\r\n    \"\"\"Returns k * point computed using the double and point_add algorithm.\"\"\"\r\n    assert is_on_curve(point)\r\n    k = int(k)\r\n    if k % curve.n == 0 or point is None:\r\n        return None\r\n\r\n    if k < 0:\r\n        # k * point = -k * (-point)\r\n        return scalar_mult(-k, point_neg(point))\r\n\r\n    result = None\r\n    addend = point\r\n\r\n    while k:\r\n        if int(k) & 1:\r\n            # Add.\r\n            result = point_add(result, addend)\r\n\r\n        # Double.\r\n        addend = point_add(addend, addend)\r\n\r\n        k >>= 1\r\n\r\n    assert is_on_curve(result)\r\n\r\n    return result\r\n\r\n\r\ndef koblitz_en (m,ab):\r\n    b = stohx(m)\r\n    b = hxtoi(b)\r\n    bet = ab\r\n    tmpy = (b**3 + 7)**(1/2)\r\n    rnum =  random.randrange(1, curve.n)\r\n    secr1 = scalar_mult( int(rnum), curve.g)\r\n    tmp = scalar_mult( rnum, bet)\r\n    secr2 =(b+tmp[0],tmpy+ tmp[1])\r\n    return secr1, secr2\r\n\r\n\r\ndef make_keypair():\r\n    private_key = random.randrange(1, curve.n)  # get a random number to multiply with\r\n    public_key = scalar_mult(private_key, curve.g)\r\n    return private_key, public_key\r\n\r\n\r\ndef koblitz_de(secr, ab):\r\n    a = scalar_mult( ab, secr[0])\r\n    b = (secr[1][0]-a[0], secr[1][1]-a[1])\r\n    c = itohx(b[0])\r\n    # print(ab)\r\n    c = hxtos(c)\r\n    return c\r\n\r\n\r\ndef koblitz_en_str(m, ab):\r\n    return str(koblitz_en(m, ab))\r\n\r\n\r\ndef koblitz_de_str(ciphertext, keyset):\r\n    left, right = ciphertext[2:-2].split(\"), (\")\r\n    l1, l2 = left.split(\", \")\r\n    r1, r2 = right.split(\", \")\r\n    cipher = ((int(l1), int(l2)), (int(r1), float(r2)))\r\n    return koblitz_de(cipher, keyset)\r\n\r\n\r\n# apr, apu = make_keypair()\r\n# bpr, bpu = make_keypair()\r\n# print(apr, apu)\r\n# print(bpr, bpu)\r\n# s1 = scalar_mult(apr, bpu)\r\n# s2 = scalar_mult(bpr, apu)\r\n# a = \"ABCD1234wpbaKse4kCx8guvlqADTF-gkSLU=\"\r\n# print(apr, apu)\r\n# b = stohx(a)\r\n# spri = s1[0]\r\n# spub = scalar_mult(s1[0], curve.g)\r\n# print(\"Encrypting: \",a)\r\n# print(\"            \",b)\r\n# b = koblitz_en(a,spub)\r\n# print(\"Cypher: \",b)\r\n# c = koblitz_de(b,spri)\r\n# #\r\n# print(\"A Decrypted: \",c)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ECCryp.py	(revision 510be7965914720463c02818543a520d7ed72d70)
+++ ECCryp.py	(date 1597040691291)
@@ -193,22 +193,22 @@
     return koblitz_de(cipher, keyset)
 
 
-# apr, apu = make_keypair()
-# bpr, bpu = make_keypair()
+apr, apu = make_keypair()
+bpr, bpu = make_keypair()
 # print(apr, apu)
 # print(bpr, bpu)
-# s1 = scalar_mult(apr, bpu)
-# s2 = scalar_mult(bpr, apu)
-# a = "ABCD1234wpbaKse4kCx8guvlqADTF-gkSLU="
-# print(apr, apu)
-# b = stohx(a)
-# spri = s1[0]
-# spub = scalar_mult(s1[0], curve.g)
-# print("Encrypting: ",a)
-# print("            ",b)
-# b = koblitz_en(a,spub)
-# print("Cypher: ",b)
-# c = koblitz_de(b,spri)
-# #
-# print("A Decrypted: ",c)
+s1 = scalar_mult(apr, bpu)
+s2 = scalar_mult(bpr, apu)
+a = "ABCD1234wpbaKse4kCx8guvlqADTF-gkSLU=Cx8g"
+print('len',len(a))
+b = stohx(a)
+spri = s1[0]
+spub = scalar_mult(s1[0], curve.g)
+print("Encrypting: ",a)
+print("            ",b)
+b = koblitz_en(a,spub)
+print("Cypher: ",b)
+c = koblitz_de(b,spri)
+#
+print("A Decrypted: ",c)
 
Index: YiYangReadme.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- YiYangReadme.txt	(date 1597039350727)
+++ YiYangReadme.txt	(date 1597039350727)
@@ -0,0 +1,1 @@
+ECC encryption implementation:
