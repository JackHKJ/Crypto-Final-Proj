Index: server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nfrom KEYgen import ECCsrv\r\nfrom Algorithms import *\r\nfrom ECCryp import *\r\nfrom ElGamal import *\r\nfrom MACer import *\r\nfrom IntegratedEnDecryptor import *\r\n\"\"\"\r\nSSL handshake protocol\r\n1. client: Choice of 'ECC', 'DES', 'ELG'\r\n2. server: nonce\r\n3. client: nonce+4\r\n4. server: nonce+2\r\n5. client: E(nonce+5)\r\n6. server: E(secret)\r\n7. client: Esec(message)\r\n\"\"\"\r\n\r\n       \r\n\r\n\r\nen_method = \"ELG\"\r\n#KEYS GOES HERE, TESTING ONLY!!!\r\npri, pub = 17266110910292182863031101798374952031947451314643790344773650325784057863506, (63418887483913902302210242333028958573736406591311866468970740733910330138582, 100732508251634749738002515251900185798485578709518688083838565500932099246055)\r\n\r\nsecret = 'hello'\r\nbalance = 100.00\r\nserver = socket.socket()\r\nhost = socket.gethostname()\r\nport = 8808\r\nserver.bind((host, port))\r\nserver.listen(5)\r\nr_message = \"\"\r\nconnect, addr = server.accept()\r\nprint(\"address: \", addr)\r\n\r\n\r\nr_cipher = connect.recv(1024).decode()\r\nr_message = to_string(r_cipher)\r\nen_method = r_message\r\nnce = nonce_new(en_method)\r\nconnect.send(nce.encode())\r\nr_cipher = connect.recv(1024).decode()\r\nr_message = to_string(r_cipher)\r\ntmpnce = nonce_inc(nce)\r\ntmpnce = nonce_inc(tmpnce)\r\ntmpnce = nonce_inc(tmpnce)\r\ntmpnce = nonce_inc(tmpnce)\r\n\r\nif(tmpnce != r_message):\r\n    print(\"Handshake failed! @nce Closing connection {}\".format(addr))\r\n    connect.close()\r\n    exit()\r\nnce = nonce_inc(nce)\r\ntmpnce = nonce_inc(nce)\r\ntclnt = koblitz_en_str(nce, pub)\r\ncheckp = koblitz_en(tmpnce,pub)\r\n##\r\nconnect.send(tclnt.encode())\r\nr_cipher = connect.recv(10240).decode()\r\n\r\n\r\nr_message = to_string(r_cipher)\r\nif r_message != tmpnce:\r\n    print(r_cipher,checkp)\r\n    print(\"Handshake failed! @dec Closing connection {}\".format(addr))\r\n    connect.close()\r\n    exit()\r\n    \r\n## generating key pairs for encryption\r\nif en_method == \"ELG\":\r\n    SERVER_ENCKEY, CLIENT_DECKEY = KeyGen()\r\n    CLIENT_ENCKEY, SERVER_DECKEY = KeyGen()\r\nif en_method == \"DES\":\r\n    SERVER_ENCKEY = CLIENT_DECKEY =  keygen()\r\n    CLIENT_ENCKEY =  SERVER_DECKEY = keygen()\r\nif en_method == \"DES\":\r\n    CLIENT_DECKEY, SERVER_ENCKEY = make_keypair()\r\n    SERVER_DECKEY, CLIENT_ENCKEY = make_keypair()\r\n\r\nMAC_KEY = random.randint(2**62,2**63)\r\n\r\n#sec1 = str(CLIENT_DECKEY)\r\n#sec1 = koblitz_en(sec1, pub)\r\n#print(sec1)\r\n#connect.send(sec1.encode())\r\n\r\n#sec2 = str(CLIENT_ENCKEY)\r\n#sec2 = koblitz_en(sec2, pub)\r\n#connect.send(sec1.encode())\r\n\r\n#sec3 = str(MAC_KEY)\r\n#sec3 = koblitz_en(sec3, pub)\r\n#connect.send(sec1.encode())\r\n\r\n\r\nprint(\"SSL handshake complete\")\r\n\r\n## NEED IMPLEMENTATION #########################################\r\n## need exchange before the actual communication\r\nSERVER_ENCKEY = (111424227728653973693487741115936850362795211037851575928498626423329976428198, 11142569238708697687739565437964320833265344920279491677967914583507687303629)\r\nSERVER_DECKEY = 91838603497381221099410955303817289674795061747944840649439772219237063007634\r\nMAC_KEY = \"MACKEY\"\r\n## END ###########################################################\r\n\r\n#if en_method == \"ELG\":\r\n    #pass\r\n    ##ElGamal private and public key generation\r\n#else:\r\n    #pri, pub = make_keypair()# key gen for int pri, tuple (int , int) pub\r\n\r\nwhile r_message != \"exit\":\r\n    r_cipher = connect.recv(10240).decode()\r\n    r_message = to_string(r_cipher)\r\n    \r\n    ## decrypt here\r\n    #if en_method == \"ECC\":\r\n        #pass\r\n        ##encrypt with ECC\r\n    #elif en_method == \"DES\":\r\n        #pass\r\n        ##encrypt with DES\r\n    #elif en_method == \"ELG\":\r\n        #pass\r\n        ##encrypt with ELG\r\n    r_message = decryptor(en_method,r_message,MAC_KEY,SERVER_DECKEY)    \r\n    print(\"<<<\", r_message)\r\n    \r\n    command = r_message.split()\r\n    s_message = \"\"\r\n    if command[0] == \"deposit\":\r\n        if len(command) != 2:\r\n            s_message = \"Invalid command!\\nSee commands using \\\"help\\\"\"\r\n        elif command[1].isnumeric():\r\n            balance += float(command[1])\r\n            s_message = \"Successfully deposited ${}\".format(command[1])\r\n    elif command[0] == \"withdraw\":\r\n        if len(command) != 2:\r\n            s_message = \"Invalid command!\\nSee commands using \\\"help\\\"\"\r\n        elif command[1].isnumeric():\r\n            if float(command[1]) > balance:\r\n                s_message = \"Not enough balance!\".format(command[1])\r\n            else:\r\n                balance -= float(command[1])\r\n                s_message = \"Successfully withdrew ${}\".format(command[1])\r\n    elif command[0] == \"balance\":\r\n        s_message = \"Balance: ${}\".format(balance)\r\n    elif command[0] == \"hello\":\r\n        s_message = \"hello\"\r\n    elif command[0] == \"exit\":\r\n        s_message = \"Goodbye!\"\r\n    elif command[0] == \"help\":\r\n        s_message = \"Deposit: deposit (amount)\\n\" \\\r\n                    \"Withdraw: withdraw (amount)\\n\" \\\r\n                    \"Check Balance: balance\\n\" \\\r\n                    \"Exit: exit\"\r\n    else:\r\n        s_message = \"Invalid command!\\nSee commands using \\\"help\\\"\"\r\n    # encrypt here\r\n    print(\"sending message: \"+s_message)\r\n    s_cipher = encryptor(en_method,s_message,MAC_KEY,SERVER_ENCKEY)      \r\n    connect.send(s_cipher.encode())\r\nconnect.close()\r\nserver.close()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- server.py	(revision adea398dde413bcb83283157f821da59806e5068)
+++ server.py	(date 1597033571483)
@@ -74,7 +74,7 @@
 if en_method == "DES":
     SERVER_ENCKEY = CLIENT_DECKEY =  keygen()
     CLIENT_ENCKEY =  SERVER_DECKEY = keygen()
-if en_method == "DES":
+if en_method == "ECC":
     CLIENT_DECKEY, SERVER_ENCKEY = make_keypair()
     SERVER_DECKEY, CLIENT_ENCKEY = make_keypair()
 
Index: client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nfrom KEYgen import *\r\nfrom Algorithms import *\r\nfrom ECCryp import *\r\nfrom IntegratedEnDecryptor import *\r\n\r\n#en_method = \"ELG\"\r\nen_method = input(\"Enter the encryption method (ELG/ECC/DES) you want: \")\r\nif en_method != \"ELG\" and en_method != \"ECC\" and en_method != \"DES\":\r\n    en_method = \"ELG\"\r\n#KEYS GOES HERE, TESTING ONLY!!!\r\npri, pub = 17266110910292182863031101798374952031947451314643790344773650325784057863506, (63418887483913902302210242333028958573736406591311866468970740733910330138582, 100732508251634749738002515251900185798485578709518688083838565500932099246055)\r\ns_message = \"\"\r\nhost = socket.gethostname()\r\nport = 8808\r\nclient = socket.socket()\r\nclient.connect((host, port))\r\ns_cipher = to_binary(en_method)\r\nclient.send(s_cipher.encode())\r\nr_cipher = client.recv(1024).decode()\r\nr_cipher = nonce_inc(r_cipher)\r\nr_cipher = nonce_inc(r_cipher)\r\nr_cipher = nonce_inc(r_cipher)\r\nr_cipher = nonce_inc(r_cipher)\r\ns_cipher = to_binary(r_cipher)\r\nclient.send(s_cipher.encode())\r\n##\r\ncypher = client.recv(10240).decode()\r\ndec = koblitz_de_str(cypher,pri)\r\nr_cipher = nonce_inc(dec)\r\ns_cipher = to_binary(r_cipher)\r\nclient.send(s_cipher.encode())\r\n\r\n#sec1  = client.recv(10240).decode()\r\n#sec1 = koblitz_de(sec1, pri)\r\n#sec2  = client.recv(10240).decode()\r\n#sec2 = koblitz_de(sec2, pri)\r\n#sec3  = client.recv(10240).decode()\r\n#sec3 = koblitz_de(sec3, pri)\r\n\r\n#print(sec1,sec2,sec3)\r\n\r\nprint(\"SSL handshake complete\")\r\n\r\n\r\n## NEED IMPLEMENTATION #########################################\r\n## need exchange before the actual communication\r\nCLIENT_ENCKEY =  (57347989155196480278832323052921971267628012422077849954342099867867099811588, 5737424824561123120621740469216300061329422523941799479443051959145616940579)\r\nCLIENT_DECKEY = 4968098174954198194808929959705034417145300753381397683341648479118799125144\r\nMAC_KEY = \"MACKEY\"\r\n## END ###########################################################\r\n\r\n\r\nwhile s_message != \"exit\":\r\n    s_message = input(\">>> \")\r\n    print(\"Sending: \"+s_message)\r\n    s_message = encryptor(en_method, s_message, MAC_KEY, CLIENT_ENCKEY)    \r\n    s_cipher = to_binary(s_message)\r\n    client.send(s_cipher.encode())\r\n    \r\n    r_cipher = client.recv(10240).decode()\r\n    r_message = decryptor(en_method,r_cipher, MAC_KEY, CLIENT_DECKEY)\r\n    print(r_message)\r\n    if(r_message == \"Goodbye!\"):\r\n        break\r\nclient.close()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- client.py	(revision adea398dde413bcb83283157f821da59806e5068)
+++ client.py	(date 1597032918214)
@@ -18,6 +18,7 @@
 s_cipher = to_binary(en_method)
 client.send(s_cipher.encode())
 r_cipher = client.recv(1024).decode()
+
 r_cipher = nonce_inc(r_cipher)
 r_cipher = nonce_inc(r_cipher)
 r_cipher = nonce_inc(r_cipher)
Index: YiYangReadme.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- YiYangReadme.txt	(date 1597034139573)
+++ YiYangReadme.txt	(date 1597034139573)
@@ -0,0 +1,1 @@
+ECC encryption implementation:
